<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2&family=Outfit:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <title>Luxury Cocktails by Dazfer Subero</title>
</head>
<body>
    <div class="split-container">
        <div class="split-half split-top"></div>
        <div class="split-half split-bottom"></div>
    </div>

    <div class="loading-container">
        <div class="shaker" id="shaker">
            <img src="assets/shaker.png" alt="Cocktail Shaker" class="shaker-image">
        </div>
        <div class="loading-text">Getting your cocktail ready...</div>
    </div>

    <div class="sparkles" id="sparkles"></div>

    <div class="content-page">
        <div class="parallax-wrapper">
            <!-- 3D parallax layers -->
            <div class="parallax-layer" data-depth="0.2">
                <img src="assets/bar-background-large.jpg" alt="Bar Background" class="layer-image">
            </div>
            <!-- Hero Text -->
             <div class="hero-content">
                <h1 class="hero-title">DAZFER SUBERO</h1>
                <p class="hero-subtitle">Master of Liquid Architecture</p>
             </div>
        </div>

        <!-- Scroll sections -->
        <section class="scroll-section section-1">
            <div class="section-content">
                <h2 class="section-title">The Art of Mixology</h2>
                <div class="floating-element glass-1"></div>
                <div class="floating-element glass-2"></div>
            </div>
        </section>

        <section class="scroll-section section-2">
            <div class="section-content">
                <h2 class="section-title">Crafted Experiences</h2>
                <div class="rotating-cube">
                    <div class="cube-face front"></div>
                    <div class="cube-face back"></div>
                    <div class="cube-face left"></div>
                    <div class="cube-face right"></div>
                    <div class="cube-face top"></div>
                    <div class="cube-face bottom"></div>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Shaking animation
        const shaker = document.getElementById('shaker');
        const splitTop = document.querySelector('.split-top');
        const splitBottom = document.querySelector('.split-bottom');
        const sparklesContainer = document.getElementById('sparkles');

        // start shaking immediately
        shaker.classList.add('shaking');

        // create slight sparkles effect
        function createSparkle() {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.left = Math.random() * 100 + '%';
            sparkle.style.top = Math.random() * 100 + '%';
            sparkle.style.animationDelay = Math.random() * 0.5 + 's';
            sparklesContainer.appendChild(sparkle);

            setTimeout(() => {
                sparkle.classList.add('animate');
            }, 100);

            setTimeout(() => {
                sparkle.remove();
            }, 1500);
        }

        // create sparkles during shaking (reduced for elegance)
        const sparkleInterval = setInterval(createSparkle, 400);

        // after 2.5s stop shaking and trigger split
        setTimeout(() => {
            shaker.classList.remove('shaking');
            clearInterval(sparkleInterval);
            document.querySelector('.loading-container').classList.add('hide');
            
            // Remove sparkles completely after loading
            setTimeout(() => {
                sparklesContainer.remove();
            }, 800);
            
            // trigger split
            setTimeout(() => {
                splitTop.classList.add('open');
                splitBottom.classList.add('open');
                
                // Wait for split animation to complete then show content
                setTimeout(() => {
                    const contentPage = document.querySelector('.content-page');
                    contentPage.style.animationDelay = '0s';
                    contentPage.style.animation = 'mindBendingEntry 2.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                    contentPage.style.pointerEvents = 'auto';

                    // Enable scrolling after animation completes
                    setTimeout(() => {
                        document.body.classList.add('scrollable');
                        // Hide split container after content is visible
                        document.querySelector('.split-container').style.display = 'none';
                        initParallax();
                    }, 2500);
                }, 900);
            }, 500);
        }, 2500);

        // 3d parallax
        function initParallax() {
            const wrapper = document.querySelector('.parallax-wrapper');
            const layers = document.querySelectorAll('.parallax-layer');
            const heroContent = document.querySelector('.hero-content');
            const sections = document.querySelectorAll('.scroll-section');
            const floatingElements = document.querySelectorAll('.floating-element');
            const rotatingCube = document.querySelector('.rotating-cube');

            let scrollY = 0;
            let ticking = false;

            function updateParallax() {
                scrollY = window.pageYOffset;
                const windowHeight = window.innerHeight;

                // parallax layers with zoom
                layers.forEach(layer => {
                    const depth = layer.dataset.depth;
                    const moveY = -(scrollY * depth);
                    const scale = 1 + (scrollY * 0.0005 * depth);
                    layer.style.transform = `translate3d(0, ${moveY}px, 0) scale(${scale})`;
                });

                // hero content fade and move
                const heroOpacity = Math.max(0, 1 - scrollY / (windowHeight * 0.8));
                const heroScale = 1 - (scrollY * 0.0003);
                heroContent.style.opacity = heroOpacity;
                heroContent.style.transform = `translate(-50%, calc(-50% + ${scrollY * 0.3}px)) scale(${heroScale})`;

                // 3D trnaform for sections
                sections.forEach((section, index) => {
                    const sectionTop = section.offsetTop;
                    const sectionHeight = section.offsetHeight;
                    const sectionContainer = sectionTop + sectionHeight / 2;
                    const distanceFromCenter = scrollY + windowHeight / 2 - sectionContainer;
                    const normalizedDistance = distanceFromCenter / windowHeight;

                    // 3D rotation based on scroll
                    const rotateX = normalizedDistance * 20;
                    const translateZ = Math.abs(normalizedDistance) * -100;
                    const opacity = 1 - Math.abs(normalizedDistance) * 0.5;

                    section.style.transform = `rotateX(${rotateX}deg) translateZ(${translateZ}px)`;
                    section.style.opacity = Math.max(0.3, opacity);
                });

                // floating elements animation
                floatingElements.forEach((el, index) => {
                    const speed = 0.5 + (index * 0.2);
                    const rotation = scrollY * speed * 0.1;
                    const floatY = Math.sin(scrollY * 0.002 + index) * 20;
                    el.style.transform = `rotate3d(1, 1, 0, ${rotation}deg) translateY(${floatY}px)`;
                });

                // rotating cube
                if (rotatingCube) {
                    const cubeRotation = scrollY * 0.1;
                    rotatingCube.style.transform = `rotateX(${cubeRotation}deg) rotateY(${cubeRotation * 1.5}deg)`;
                }

                ticking = false;
            }

            function requestTick() {
                if (!ticking) {
                    requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            }

            // mouse parallax for extra depth
            document.addEventListener('mousemove', (e) => {
                const mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
                const mouseY = (e.clientY / window.innerHeight - 0.5) * 2;

                layers.forEach((layer, index) => {
                    const depth = layer.dataset.depth;
                    const moveX = mouseX * depth * 50;
                    const moveY = mouseY * depth * 50;
                    
                    // Get current scroll-based transform
                    const currentMoveY = -(scrollY * depth);
                    const currentScale = 1 + (scrollY * 0.0005 * depth);
                    
                    // Combine scroll and mouse transforms
                    layer.style.transform = `translate3d(${moveX}px, ${currentMoveY + moveY}px, 0) scale(${currentScale})`;
                });
            });

            window.addEventListener('scroll', requestTick);
            updateParallax();
        }
    </script>
    <script src="js/main/main.js"></script>
</body>
</html>